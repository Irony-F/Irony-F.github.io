---
layout: post
cover: 'assets/images/cover14.jpg'
title: 《C陷阱与缺陷》学习笔记
date:   2018-05-03-19:28:00
tags: Changing
subclass: 'post tag-fiction'
categories: 'Irony-F'
navigation: True
logo: 'assets/images/ghost.png'
---





#
《C陷阱与缺陷》学习笔记-

######
最近学习压力太大了，缓慢学习中。不指望赶超大佬什么的了=-=让我做一只愉快的咸鱼吧，学习笔记什么的，我会慢慢补起来的。加油啊！咸鱼！######



##0.说说自己##

说实话吧，在自己短暂的编程学习过程中，对c/c++的认识确实非常浅显，对自己的要求就是，写出了，对程序的要求就是，跑出预想结果，仅此而已。但事实上c和c++这两门语言的特性决定了其编程绝非如此，我们有很多需要考虑了的问题，比如我们必须做内存的保姆。所以能深入地了解他们的特性和在编程中需要注意的事项，是极好的。


##1.词法陷阱##
	&和&&
	|和||
	编译器对程序的符号分解：从左到右逐个字符读入，如果能多个连续组成符号，则读入，直到读入的字符不在可能组成一个有意义的符号。
	基于上一条，注意空格和括号的使用。
	数字的进制写法问题
	单引号括起来的字符代表一个整数，双引号括起来的是一个指针，以一个额外的二进制字符'\0'结尾。


##
2.语法陷阱##

###函数申明：###

函数的返回值可以为一个指针，而指针也可以指向一个函数，然后通过对这个函数解除引用来（同时根据需要传入参数）调用这个函数。注意函数返回值的类型。对于函数的申明，可以涉及到对指针解除引用之后再传参数。

    	void (*singal (something) )(int);
		//此处的理解是：将适当的参数something传入signal函数中，对signal函数返回值(函数指针类型)解除引用，再传入一个int型的参数调用解除引用后的函数，最后返回类型为void。

###运算的优先级###

+ 前述运算>单目运算>双目运算>多目运算
+ ()的优先级永远最高
+ ！，~，++，(typeof) * & sizeof 的结合性为从右自左
+ 算数运算>移位运算>关系运算>逻辑运
+ 逗号的优先级最低

###switch###

case后不接break，将一直执行case之下的所有代码，直到break出现，因此某些情况下可以巧妙的使用break/省略break来优化代码。

##3.语义陷阱##

###数组和指针###

+ 任何一个数组下标运算都是用于一个对应的指针运算。指针加一个整数，不等于，给指针的二进制表示数加一个整数
+ 除了数组名被作为sizeof的参数这一情形，其他情况下数组名都代表指向数组的下标为0的元素的指针。
+ 将数组作为参数是毫无意义的，所以c语音会自动将作为参数的数组声明转换为相应的指针声明。
+ 复制指针并不同时复制指针所指的数据，只是复制了数据的“地址”。
+ 当常数0诶转换为指针时，这个指针绝对不能被解除应用。
+ --n>=0 的效率大于等于n-->0.
+ 数组实际不存在溢界，只是超出数组的范围的访问是一个指向数组之后内存单元的指针，虽然不能对数组进行访问，但是可以用这种方式来取值，进行赋值和比较。


##4.连接##

+ 连接器把由编译器或者会汇编器生成的若干目标模块，组合为一个载入模块，或可执行实体。
+ 连接器输入：目标模块，库文件；输出：载入模块。在生成输出时，记录外部对象的引用。
+ static：避免重命名，当函数只作用于自己的源文件时，可以声明为此。
+

##5.库函数##

+ getchar()

		while(c=getchar()!=EOF)
		//存在的问题：输入字符被截断，使c与EOF相同；c不可能取到EOF

+ setbuf()
		
		setbuf(stdbuf,buf);
		//buf会在main函数结束之前被释放。
		//此处：让部分成为静态数组，在main函数外声明
		static char buf[buffsiz];
		//或者动态分配缓存，使用只有手动释放
		char *malloc();
		setbuf(stdbuf,malloc(bufsiz));

##6.预处理##

+ 宏定义之中的空格
+ 宏不是函数，使用时为了避免问题，用括号将参数都括起来,整个表达式也应该用括号括起来。

		#define ab(x) (((x)>=0))?(x):-(x))
+ 在宏之中，一个操作数被多次使用，就会被多次求值。如果使用像i++这样的参数，将会导致错误。为了避免，可以写成函数。
+ 宏定义不是语句，没有“；”。
+ 宏不是类型定义
		
		#define T1 struct foo*;	
		T1 a,b;
		//此处扩展之后，为：
		struct foo* a,b;
		//a为指针，b为struct对象，

		#define T2 struct foo *T2
		T2 a, b;
		//扩展之后：
		struct foo *a,*b;
		//两个指针

